{"version":3,"sources":["../src/main.ts","../src/auth.ts","../src/lib/paths.ts","../src/lib/state.ts","../src/lib/token.ts","../src/lib/api-config.ts","../src/lib/error.ts","../src/services/github/get-copilot-token.ts","../src/services/github/get-device-code.ts","../src/services/github/get-user.ts","../src/services/github/poll-access-token.ts","../src/lib/utils.ts","../src/services/copilot/get-models.ts","../src/services/get-vscode-version.ts","../src/start.ts","../src/lib/shell.ts","../src/server.ts","../src/routes/chat-completions/route.ts","../src/routes/chat-completions/handler.ts","../src/lib/approval.ts","../src/lib/rate-limit.ts","../src/lib/tokenizer.ts","../src/services/copilot/create-chat-completions.ts","../src/routes/embeddings/route.ts","../src/services/copilot/create-embeddings.ts","../src/routes/messages/route.ts","../src/routes/messages/handler.ts","../src/routes/messages/utils.ts","../src/routes/messages/non-stream-translation.ts","../src/routes/messages/stream-translation.ts","../src/routes/models/route.ts","../src/routes/token/route.ts","../src/routes/usage/route.ts","../src/services/github/get-copilot-usage.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { defineCommand, runMain } from \"citty\"\n\nimport { auth } from \"./auth\"\nimport { start } from \"./start\"\n\nconst main = defineCommand({\n  meta: {\n    name: \"copilot-api\",\n    description:\n      \"A wrapper around GitHub Copilot API to make it OpenAI compatible, making it usable for other tools.\",\n  },\n  subCommands: { auth, start },\n})\n\nawait runMain(main)\n","#!/usr/bin/env node\n\nimport { defineCommand } from \"citty\"\nimport consola from \"consola\"\n\nimport { PATHS, ensurePaths } from \"./lib/paths\"\nimport { state } from \"./lib/state\"\nimport { setupGitHubToken } from \"./lib/token\"\n\ninterface RunAuthOptions {\n  verbose: boolean\n  showToken: boolean\n}\n\nexport async function runAuth(options: RunAuthOptions): Promise<void> {\n  if (options.verbose) {\n    consola.level = 5\n    consola.info(\"Verbose logging enabled\")\n  }\n\n  state.showToken = options.showToken\n\n  await ensurePaths()\n  await setupGitHubToken({ force: true })\n  consola.success(\"GitHub token written to\", PATHS.GITHUB_TOKEN_PATH)\n}\n\nexport const auth = defineCommand({\n  meta: {\n    name: \"auth\",\n    description: \"Run GitHub auth flow without running the server\",\n  },\n  args: {\n    verbose: {\n      alias: \"v\",\n      type: \"boolean\",\n      default: false,\n      description: \"Enable verbose logging\",\n    },\n    \"show-token\": {\n      type: \"boolean\",\n      default: false,\n      description: \"Show GitHub token on auth\",\n    },\n  },\n  run({ args }) {\n    return runAuth({\n      verbose: args.verbose,\n      showToken: args[\"show-token\"],\n    })\n  },\n})\n","import fs from \"node:fs/promises\"\nimport os from \"node:os\"\nimport path from \"node:path\"\n\nconst APP_DIR = path.join(os.homedir(), \".local\", \"share\", \"copilot-api\")\n\nconst GITHUB_TOKEN_PATH = path.join(APP_DIR, \"github_token\")\n\nexport const PATHS = {\n  APP_DIR,\n  GITHUB_TOKEN_PATH,\n}\n\nexport async function ensurePaths(): Promise<void> {\n  await fs.mkdir(PATHS.APP_DIR, { recursive: true })\n  await ensureFile(PATHS.GITHUB_TOKEN_PATH)\n}\n\nasync function ensureFile(filePath: string): Promise<void> {\n  try {\n    await fs.access(filePath, fs.constants.W_OK)\n  } catch {\n    await fs.writeFile(filePath, \"\")\n    await fs.chmod(filePath, 0o600)\n  }\n}\n","import type { ModelsResponse } from \"~/services/copilot/get-models\"\n\nexport interface State {\n  githubToken?: string\n  copilotToken?: string\n\n  accountType: string\n  models?: ModelsResponse\n  vsCodeVersion?: string\n\n  manualApprove: boolean\n  rateLimitWait: boolean\n  showToken: boolean\n\n  // Rate limiting configuration\n  rateLimitSeconds?: number\n  lastRequestTimestamp?: number\n}\n\nexport const state: State = {\n  accountType: \"individual\",\n  manualApprove: false,\n  rateLimitWait: false,\n  showToken: false,\n}\n","import consola from \"consola\"\nimport fs from \"node:fs/promises\"\n\nimport { PATHS } from \"~/lib/paths\"\nimport { getCopilotToken } from \"~/services/github/get-copilot-token\"\nimport { getDeviceCode } from \"~/services/github/get-device-code\"\nimport { getGitHubUser } from \"~/services/github/get-user\"\nimport { pollAccessToken } from \"~/services/github/poll-access-token\"\n\nimport { HTTPError } from \"./error\"\nimport { state } from \"./state\"\n\nconst readGithubToken = () => fs.readFile(PATHS.GITHUB_TOKEN_PATH, \"utf8\")\n\nconst writeGithubToken = (token: string) =>\n  fs.writeFile(PATHS.GITHUB_TOKEN_PATH, token)\n\nexport const setupCopilotToken = async () => {\n  const { token, refresh_in } = await getCopilotToken()\n  state.copilotToken = token\n\n  // Display the Copilot token to the screen\n  consola.debug(\"GitHub Copilot Token fetched successfully!\")\n  if (state.showToken) {\n    consola.info(\"Copilot token:\", token)\n  }\n\n  const refreshInterval = (refresh_in - 60) * 1000\n  setInterval(async () => {\n    consola.debug(\"Refreshing Copilot token\")\n    try {\n      const { token } = await getCopilotToken()\n      state.copilotToken = token\n      consola.debug(\"Copilot token refreshed\")\n      if (state.showToken) {\n        consola.info(\"Refreshed Copilot token:\", token)\n      }\n    } catch (error) {\n      consola.error(\"Failed to refresh Copilot token:\", error)\n      throw error\n    }\n  }, refreshInterval)\n}\n\ninterface SetupGitHubTokenOptions {\n  force?: boolean\n}\n\nexport async function setupGitHubToken(\n  options?: SetupGitHubTokenOptions,\n): Promise<void> {\n  try {\n    const githubToken = await readGithubToken()\n\n    if (githubToken && !options?.force) {\n      state.githubToken = githubToken\n      if (state.showToken) {\n        consola.info(\"GitHub token:\", githubToken)\n      }\n      await logUser()\n\n      return\n    }\n\n    consola.info(\"Not logged in, getting new access token\")\n    const response = await getDeviceCode()\n    consola.debug(\"Device code response:\", response)\n\n    consola.info(\n      `Please enter the code \"${response.user_code}\" in ${response.verification_uri}`,\n    )\n\n    const token = await pollAccessToken(response)\n    await writeGithubToken(token)\n    state.githubToken = token\n\n    if (state.showToken) {\n      consola.info(\"GitHub token:\", token)\n    }\n    await logUser()\n  } catch (error) {\n    if (error instanceof HTTPError) {\n      consola.error(\"Failed to get GitHub token:\", await error.response.json())\n      throw error\n    }\n\n    consola.error(\"Failed to get GitHub token:\", error)\n    throw error\n  }\n}\n\nasync function logUser() {\n  const user = await getGitHubUser()\n  consola.info(`Logged in as ${user.login}`)\n}\n","import { randomUUID } from \"node:crypto\"\n\nimport type { State } from \"./state\"\n\nexport const standardHeaders = () => ({\n  \"content-type\": \"application/json\",\n  accept: \"application/json\",\n})\n\nconst COPILOT_VERSION = \"0.26.7\"\nconst EDITOR_PLUGIN_VERSION = `copilot-chat/${COPILOT_VERSION}`\nconst USER_AGENT = `GitHubCopilotChat/${COPILOT_VERSION}`\n\nconst API_VERSION = \"2025-04-01\"\n\nexport const copilotBaseUrl = (state: State) =>\n  state.accountType === \"individual\" ?\n    \"https://api.githubcopilot.com\"\n  : `https://api.${state.accountType}.githubcopilot.com`\nexport const copilotHeaders = (state: State, vision: boolean = false) => {\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${state.copilotToken}`,\n    \"content-type\": standardHeaders()[\"content-type\"],\n    \"copilot-integration-id\": \"vscode-chat\",\n    \"editor-version\": `vscode/${state.vsCodeVersion}`,\n    \"editor-plugin-version\": EDITOR_PLUGIN_VERSION,\n    \"user-agent\": USER_AGENT,\n    \"openai-intent\": \"conversation-panel\",\n    \"x-github-api-version\": API_VERSION,\n    \"x-request-id\": randomUUID(),\n    \"x-vscode-user-agent-library-version\": \"electron-fetch\",\n  }\n\n  if (vision) headers[\"copilot-vision-request\"] = \"true\"\n\n  return headers\n}\n\nexport const GITHUB_API_BASE_URL = \"https://api.github.com\"\nexport const githubHeaders = (state: State) => ({\n  ...standardHeaders(),\n  authorization: `token ${state.githubToken}`,\n  \"editor-version\": `vscode/${state.vsCodeVersion}`,\n  \"editor-plugin-version\": EDITOR_PLUGIN_VERSION,\n  \"user-agent\": USER_AGENT,\n  \"x-github-api-version\": API_VERSION,\n  \"x-vscode-user-agent-library-version\": \"electron-fetch\",\n})\n\nexport const GITHUB_BASE_URL = \"https://github.com\"\nexport const GITHUB_CLIENT_ID = \"Iv1.b507a08c87ecfe98\"\nexport const GITHUB_APP_SCOPES = [\"read:user\"].join(\" \")\n","import type { Context } from \"hono\"\nimport type { ContentfulStatusCode } from \"hono/utils/http-status\"\n\nimport consola from \"consola\"\n\nexport class HTTPError extends Error {\n  response: Response\n\n  constructor(message: string, response: Response) {\n    super(message)\n    this.response = response\n  }\n}\n\nexport async function forwardError(c: Context, error: unknown) {\n  consola.error(\"Error occurred:\", error)\n\n  if (error instanceof HTTPError) {\n    consola.error(\"HTTP error:\", await error.response.json())\n    const errorText = await error.response.text()\n    return c.json(\n      {\n        error: {\n          message: errorText,\n          type: \"error\",\n        },\n      },\n      error.response.status as ContentfulStatusCode,\n    )\n  }\n\n  return c.json(\n    {\n      error: {\n        message: (error as Error).message,\n        type: \"error\",\n      },\n    },\n    500,\n  )\n}\n","import { GITHUB_API_BASE_URL, githubHeaders } from \"~/lib/api-config\"\nimport { HTTPError } from \"~/lib/error\"\nimport { state } from \"~/lib/state\"\n\nexport const getCopilotToken = async () => {\n  const response = await fetch(\n    `${GITHUB_API_BASE_URL}/copilot_internal/v2/token`,\n    {\n      headers: githubHeaders(state),\n    },\n  )\n\n  if (!response.ok) throw new HTTPError(\"Failed to get Copilot token\", response)\n\n  return (await response.json()) as GetCopilotTokenResponse\n}\n\n// Trimmed for the sake of simplicity\ninterface GetCopilotTokenResponse {\n  expires_at: number\n  refresh_in: number\n  token: string\n}\n","import {\n  GITHUB_APP_SCOPES,\n  GITHUB_BASE_URL,\n  GITHUB_CLIENT_ID,\n  standardHeaders,\n} from \"~/lib/api-config\"\nimport { HTTPError } from \"~/lib/error\"\n\nexport async function getDeviceCode(): Promise<DeviceCodeResponse> {\n  const response = await fetch(`${GITHUB_BASE_URL}/login/device/code`, {\n    method: \"POST\",\n    headers: standardHeaders(),\n    body: JSON.stringify({\n      client_id: GITHUB_CLIENT_ID,\n      scope: GITHUB_APP_SCOPES,\n    }),\n  })\n\n  if (!response.ok) throw new HTTPError(\"Failed to get device code\", response)\n\n  return (await response.json()) as DeviceCodeResponse\n}\n\nexport interface DeviceCodeResponse {\n  device_code: string\n  user_code: string\n  verification_uri: string\n  expires_in: number\n  interval: number\n}\n","import { GITHUB_API_BASE_URL, standardHeaders } from \"~/lib/api-config\"\nimport { HTTPError } from \"~/lib/error\"\nimport { state } from \"~/lib/state\"\n\nexport async function getGitHubUser() {\n  const response = await fetch(`${GITHUB_API_BASE_URL}/user`, {\n    headers: {\n      authorization: `token ${state.githubToken}`,\n      ...standardHeaders(),\n    },\n  })\n\n  if (!response.ok) throw new HTTPError(\"Failed to get GitHub user\", response)\n\n  return (await response.json()) as GithubUserResponse\n}\n\n// Trimmed for the sake of simplicity\ninterface GithubUserResponse {\n  login: string\n}\n","import consola from \"consola\"\n\nimport {\n  GITHUB_BASE_URL,\n  GITHUB_CLIENT_ID,\n  standardHeaders,\n} from \"~/lib/api-config\"\nimport { sleep } from \"~/lib/utils\"\n\nimport type { DeviceCodeResponse } from \"./get-device-code\"\n\nexport async function pollAccessToken(\n  deviceCode: DeviceCodeResponse,\n): Promise<string> {\n  // Interval is in seconds, we need to multiply by 1000 to get milliseconds\n  // I'm also adding another second, just to be safe\n  const sleepDuration = (deviceCode.interval + 1) * 1000\n  consola.debug(`Polling access token with interval of ${sleepDuration}ms`)\n\n  while (true) {\n    const response = await fetch(\n      `${GITHUB_BASE_URL}/login/oauth/access_token`,\n      {\n        method: \"POST\",\n        headers: standardHeaders(),\n        body: JSON.stringify({\n          client_id: GITHUB_CLIENT_ID,\n          device_code: deviceCode.device_code,\n          grant_type: \"urn:ietf:params:oauth:grant-type:device_code\",\n        }),\n      },\n    )\n\n    if (!response.ok) {\n      await sleep(sleepDuration)\n      consola.error(\"Failed to poll access token:\", await response.text())\n\n      continue\n    }\n\n    const json = await response.json()\n    consola.debug(\"Polling access token response:\", json)\n\n    const { access_token } = json as AccessTokenResponse\n\n    if (access_token) {\n      return access_token\n    } else {\n      await sleep(sleepDuration)\n    }\n  }\n}\n\ninterface AccessTokenResponse {\n  access_token: string\n  token_type: string\n  scope: string\n}\n","import consola from \"consola\"\n\nimport { getModels } from \"~/services/copilot/get-models\"\nimport { getVSCodeVersion } from \"~/services/get-vscode-version\"\n\nimport { state } from \"./state\"\n\nexport const sleep = (ms: number) =>\n  new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n\nexport const isNullish = (value: unknown): value is null | undefined =>\n  value === null || value === undefined\n\nexport async function cacheModels(): Promise<void> {\n  const models = await getModels()\n  state.models = models\n}\n\nexport const cacheVSCodeVersion = async () => {\n  const response = await getVSCodeVersion()\n  state.vsCodeVersion = response\n\n  consola.info(`Using VSCode version: ${response}`)\n}\n","import { copilotBaseUrl, copilotHeaders } from \"~/lib/api-config\"\nimport { HTTPError } from \"~/lib/error\"\nimport { state } from \"~/lib/state\"\n\nexport const getModels = async () => {\n  const response = await fetch(`${copilotBaseUrl(state)}/models`, {\n    headers: copilotHeaders(state),\n  })\n\n  if (!response.ok) throw new HTTPError(\"Failed to get models\", response)\n\n  return (await response.json()) as ModelsResponse\n}\n\nexport interface ModelsResponse {\n  data: Array<Model>\n  object: string\n}\n\ninterface ModelLimits {\n  max_context_window_tokens?: number\n  max_output_tokens?: number\n  max_prompt_tokens?: number\n  max_inputs?: number\n}\n\ninterface ModelSupports {\n  tool_calls?: boolean\n  parallel_tool_calls?: boolean\n  dimensions?: boolean\n}\n\ninterface ModelCapabilities {\n  family: string\n  limits: ModelLimits\n  object: string\n  supports: ModelSupports\n  tokenizer: string\n  type: string\n}\n\ninterface Model {\n  capabilities: ModelCapabilities\n  id: string\n  model_picker_enabled: boolean\n  name: string\n  object: string\n  preview: boolean\n  vendor: string\n  version: string\n  policy?: {\n    state: string\n    terms: string\n  }\n}\n","const FALLBACK = \"1.98.1\"\n\nexport async function getVSCodeVersion() {\n  const controller = new AbortController()\n  const timeout = setTimeout(() => {\n    controller.abort()\n  }, 5000)\n\n  try {\n    const response = await fetch(\n      \"https://aur.archlinux.org/cgit/aur.git/plain/PKGBUILD?h=visual-studio-code-bin\",\n      { signal: controller.signal },\n    )\n\n    const pkgbuild = await response.text()\n    const pkgverRegex = /pkgver=([0-9.]+)/\n    const match = pkgbuild.match(pkgverRegex)\n\n    if (match) {\n      return match[1]\n    }\n\n    return FALLBACK\n  } catch {\n    return FALLBACK\n  } finally {\n    clearTimeout(timeout)\n  }\n}\n\nawait getVSCodeVersion()\n","#!/usr/bin/env node\n\nimport { defineCommand } from \"citty\"\nimport clipboard from \"clipboardy\"\nimport consola from \"consola\"\nimport { serve, type ServerHandler } from \"srvx\"\nimport invariant from \"tiny-invariant\"\n\nimport { ensurePaths } from \"./lib/paths\"\nimport { generateEnvScript } from \"./lib/shell\"\nimport { state } from \"./lib/state\"\nimport { setupCopilotToken, setupGitHubToken } from \"./lib/token\"\nimport { cacheModels, cacheVSCodeVersion } from \"./lib/utils\"\nimport { server } from \"./server\"\n\ninterface RunServerOptions {\n  port: number\n  verbose: boolean\n  accountType: string\n  manual: boolean\n  rateLimit?: number\n  rateLimitWait: boolean\n  githubToken?: string\n  claudeCode: boolean\n  showToken: boolean\n}\n\n// eslint-disable-next-line max-lines-per-function\nexport async function runServer(options: RunServerOptions): Promise<void> {\n  if (options.verbose) {\n    consola.level = 5\n    consola.info(\"Verbose logging enabled\")\n  }\n\n  state.accountType = options.accountType\n  if (options.accountType !== \"individual\") {\n    consola.info(`Using ${options.accountType} plan GitHub account`)\n  }\n\n  state.manualApprove = options.manual\n  state.rateLimitSeconds = options.rateLimit\n  state.rateLimitWait = options.rateLimitWait\n  state.showToken = options.showToken\n\n  await ensurePaths()\n  await cacheVSCodeVersion()\n\n  if (options.githubToken) {\n    state.githubToken = options.githubToken\n    consola.info(\"Using provided GitHub token\")\n  } else {\n    await setupGitHubToken()\n  }\n\n  await setupCopilotToken()\n  await cacheModels()\n\n  consola.info(\n    `Available models: \\n${state.models?.data.map((model) => `- ${model.id}`).join(\"\\n\")}`,\n  )\n\n  const serverUrl = `http://localhost:${options.port}`\n\n  if (options.claudeCode) {\n    invariant(state.models, \"Models should be loaded by now\")\n\n    const selectedModel = await consola.prompt(\n      \"Select a model to use with Claude Code\",\n      {\n        type: \"select\",\n        options: state.models.data.map((model) => model.id),\n      },\n    )\n\n    const selectedSmallModel = await consola.prompt(\n      \"Select a small model to use with Claude Code\",\n      {\n        type: \"select\",\n        options: state.models.data.map((model) => model.id),\n      },\n    )\n\n    const command = generateEnvScript(\n      {\n        ANTHROPIC_BASE_URL: serverUrl,\n        ANTHROPIC_AUTH_TOKEN: \"dummy\",\n        ANTHROPIC_MODEL: selectedModel,\n        ANTHROPIC_SMALL_FAST_MODEL: selectedSmallModel,\n      },\n      \"claude\",\n    )\n\n    clipboard.writeSync(command)\n    consola.success(\"Copied Claude Code command to clipboard!\")\n  }\n\n  consola.box(\n    `🌐 Usage Viewer: https://ericc-ch.github.io/copilot-api?endpoint=${serverUrl}/usage`,\n  )\n\n  serve({\n    fetch: server.fetch as ServerHandler,\n    port: options.port,\n  })\n}\n\nexport const start = defineCommand({\n  meta: {\n    name: \"start\",\n    description: \"Start the Copilot API server\",\n  },\n  args: {\n    port: {\n      alias: \"p\",\n      type: \"string\",\n      default: \"4141\",\n      description: \"Port to listen on\",\n    },\n    verbose: {\n      alias: \"v\",\n      type: \"boolean\",\n      default: false,\n      description: \"Enable verbose logging\",\n    },\n    \"account-type\": {\n      alias: \"a\",\n      type: \"string\",\n      default: \"individual\",\n      description: \"Account type to use (individual, business, enterprise)\",\n    },\n    manual: {\n      type: \"boolean\",\n      default: false,\n      description: \"Enable manual request approval\",\n    },\n    \"rate-limit\": {\n      alias: \"r\",\n      type: \"string\",\n      description: \"Rate limit in seconds between requests\",\n    },\n    wait: {\n      alias: \"w\",\n      type: \"boolean\",\n      default: false,\n      description:\n        \"Wait instead of error when rate limit is hit. Has no effect if rate limit is not set\",\n    },\n    \"github-token\": {\n      alias: \"g\",\n      type: \"string\",\n      description:\n        \"Provide GitHub token directly (must be generated using the `auth` subcommand)\",\n    },\n    \"claude-code\": {\n      alias: \"c\",\n      type: \"boolean\",\n      default: false,\n      description:\n        \"Generate a command to launch Claude Code with Copilot API config\",\n    },\n    \"show-token\": {\n      type: \"boolean\",\n      default: false,\n      description: \"Show GitHub and Copilot tokens on fetch and refresh\",\n    },\n  },\n  run({ args }) {\n    const rateLimitRaw = args[\"rate-limit\"]\n    const rateLimit =\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      rateLimitRaw === undefined ? undefined : Number.parseInt(rateLimitRaw, 10)\n\n    return runServer({\n      port: Number.parseInt(args.port, 10),\n      verbose: args.verbose,\n      accountType: args[\"account-type\"],\n      manual: args.manual,\n      rateLimit,\n      rateLimitWait: Boolean(args.wait),\n      githubToken: args[\"github-token\"],\n      claudeCode: args[\"claude-code\"],\n      showToken: args[\"show-token\"],\n    })\n  },\n})\n","import { execSync } from \"node:child_process\"\nimport process from \"node:process\"\n\ntype ShellName = \"bash\" | \"zsh\" | \"fish\" | \"powershell\" | \"cmd\" | \"sh\"\ntype EnvVars = Record<string, string | undefined>\n\nfunction getShell(): ShellName {\n  const { platform, ppid, env } = process\n\n  if (platform === \"win32\") {\n    try {\n      const command = `wmic process get ParentProcessId,Name | findstr \"${ppid}\"`\n      const parentProcess = execSync(command, { stdio: \"pipe\" }).toString()\n\n      if (parentProcess.toLowerCase().includes(\"powershell.exe\")) {\n        return \"powershell\"\n      }\n    } catch {\n      return \"cmd\"\n    }\n\n    return \"cmd\"\n  } else {\n    const shellPath = env.SHELL\n    if (shellPath) {\n      if (shellPath.endsWith(\"zsh\")) return \"zsh\"\n      if (shellPath.endsWith(\"fish\")) return \"fish\"\n      if (shellPath.endsWith(\"bash\")) return \"bash\"\n    }\n\n    return \"sh\"\n  }\n}\n\n/**\n * Generates a copy-pasteable script to set multiple environment variables\n * and run a subsequent command.\n * @param {EnvVars} envVars - An object of environment variables to set.\n * @param {string} commandToRun - The command to run after setting the variables.\n * @returns {string} The formatted script string.\n */\nexport function generateEnvScript(\n  envVars: EnvVars,\n  commandToRun: string = \"\",\n): string {\n  const shell = getShell()\n  const filteredEnvVars = Object.entries(envVars).filter(\n    ([, value]) => value !== undefined,\n  ) as Array<[string, string]>\n\n  let commandBlock: string\n\n  switch (shell) {\n    case \"powershell\": {\n      commandBlock = filteredEnvVars\n        .map(([key, value]) => `$env:${key} = ${value}`)\n        .join(\"; \")\n      break\n    }\n    case \"cmd\": {\n      commandBlock = filteredEnvVars\n        .map(([key, value]) => `set ${key}=${value}`)\n        .join(\" & \")\n      break\n    }\n    case \"fish\": {\n      commandBlock = filteredEnvVars\n        .map(([key, value]) => `set -gx ${key} ${value}`)\n        .join(\"; \")\n      break\n    }\n    default: {\n      // bash, zsh, sh\n      const assignments = filteredEnvVars\n        .map(([key, value]) => `${key}=${value}`)\n        .join(\" \")\n      commandBlock = filteredEnvVars.length > 0 ? `export ${assignments}` : \"\"\n      break\n    }\n  }\n\n  if (commandBlock && commandToRun) {\n    const separator = shell === \"cmd\" ? \" & \" : \" && \"\n    return `${commandBlock}${separator}${commandToRun}`\n  }\n\n  return commandBlock || commandToRun\n}\n","import { Hono } from \"hono\"\nimport { cors } from \"hono/cors\"\nimport { logger } from \"hono/logger\"\n\nimport { completionRoutes } from \"./routes/chat-completions/route\"\nimport { embeddingRoutes } from \"./routes/embeddings/route\"\nimport { messageRoutes } from \"./routes/messages/route\"\nimport { modelRoutes } from \"./routes/models/route\"\nimport { tokenRoute } from \"./routes/token/route\"\nimport { usageRoute } from \"./routes/usage/route\"\n\nexport const server = new Hono()\n\nserver.use(logger())\nserver.use(cors())\n\nserver.get(\"/\", (c) => c.text(\"Server running\"))\n\nserver.route(\"/chat/completions\", completionRoutes)\nserver.route(\"/models\", modelRoutes)\nserver.route(\"/embeddings\", embeddingRoutes)\nserver.route(\"/usage\", usageRoute)\nserver.route(\"/token\", tokenRoute)\n\n// Compatibility with tools that expect v1/ prefix\nserver.route(\"/v1/chat/completions\", completionRoutes)\nserver.route(\"/v1/models\", modelRoutes)\nserver.route(\"/v1/embeddings\", embeddingRoutes)\n\n// Anthropic compatible endpoints\nserver.route(\"/v1/messages\", messageRoutes)\nserver.post(\"/v1/messages/count_tokens\", (c) => c.json({ input_tokens: 1 }))\n","import { Hono } from \"hono\"\n\nimport { forwardError } from \"~/lib/error\"\n\nimport { handleCompletion } from \"./handler\"\n\nexport const completionRoutes = new Hono()\n\ncompletionRoutes.post(\"/\", async (c) => {\n  try {\n    return await handleCompletion(c)\n  } catch (error) {\n    return await forwardError(c, error)\n  }\n})\n","import type { Context } from \"hono\"\n\nimport consola from \"consola\"\nimport { streamSSE, type SSEMessage } from \"hono/streaming\"\n\nimport { awaitApproval } from \"~/lib/approval\"\nimport { checkRateLimit } from \"~/lib/rate-limit\"\nimport { state } from \"~/lib/state\"\nimport { getTokenCount } from \"~/lib/tokenizer\"\nimport { isNullish } from \"~/lib/utils\"\nimport {\n  createChatCompletions,\n  type ChatCompletionResponse,\n  type ChatCompletionsPayload,\n} from \"~/services/copilot/create-chat-completions\"\n\nexport async function handleCompletion(c: Context) {\n  await checkRateLimit(state)\n\n  let payload = await c.req.json<ChatCompletionsPayload>()\n  consola.debug(\"Request payload:\", JSON.stringify(payload).slice(-400))\n\n  consola.info(\"Current token count:\", getTokenCount(payload.messages))\n\n  if (state.manualApprove) await awaitApproval()\n\n  if (isNullish(payload.max_tokens)) {\n    const selectedModel = state.models?.data.find(\n      (model) => model.id === payload.model,\n    )\n\n    payload = {\n      ...payload,\n      max_tokens: selectedModel?.capabilities.limits.max_output_tokens,\n    }\n    consola.debug(\"Set max_tokens to:\", JSON.stringify(payload.max_tokens))\n  }\n\n  const response = await createChatCompletions(payload)\n\n  if (isNonStreaming(response)) {\n    consola.debug(\"Non-streaming response:\", JSON.stringify(response))\n    return c.json(response)\n  }\n\n  consola.debug(\"Streaming response\")\n  return streamSSE(c, async (stream) => {\n    for await (const chunk of response) {\n      consola.debug(\"Streaming chunk:\", JSON.stringify(chunk))\n      await stream.writeSSE(chunk as SSEMessage)\n    }\n  })\n}\n\nconst isNonStreaming = (\n  response: Awaited<ReturnType<typeof createChatCompletions>>,\n): response is ChatCompletionResponse => Object.hasOwn(response, \"choices\")\n","import consola from \"consola\"\n\nimport { HTTPError } from \"./error\"\n\nexport const awaitApproval = async () => {\n  const response = await consola.prompt(`Accept incoming request?`, {\n    type: \"confirm\",\n  })\n\n  if (!response)\n    throw new HTTPError(\n      \"Request rejected\",\n      Response.json({ message: \"Request rejected\" }, { status: 403 }),\n    )\n}\n","import consola from \"consola\"\n\nimport type { State } from \"./state\"\n\nimport { HTTPError } from \"./error\"\nimport { sleep } from \"./utils\"\n\nexport async function checkRateLimit(state: State) {\n  if (state.rateLimitSeconds === undefined) return\n\n  const now = Date.now()\n\n  if (!state.lastRequestTimestamp) {\n    state.lastRequestTimestamp = now\n    return\n  }\n\n  const elapsedSeconds = (now - state.lastRequestTimestamp) / 1000\n\n  if (elapsedSeconds > state.rateLimitSeconds) {\n    state.lastRequestTimestamp = now\n    return\n  }\n\n  const waitTimeSeconds = Math.ceil(state.rateLimitSeconds - elapsedSeconds)\n\n  if (!state.rateLimitWait) {\n    consola.warn(\n      `Rate limit exceeded. Need to wait ${waitTimeSeconds} more seconds.`,\n    )\n    throw new HTTPError(\n      \"Rate limit exceeded\",\n      Response.json({ message: \"Rate limit exceeded\" }, { status: 429 }),\n    )\n  }\n\n  const waitTimeMs = waitTimeSeconds * 1000\n  consola.warn(\n    `Rate limit reached. Waiting ${waitTimeSeconds} seconds before proceeding...`,\n  )\n  await sleep(waitTimeMs)\n  // eslint-disable-next-line require-atomic-updates\n  state.lastRequestTimestamp = now\n  consola.info(\"Rate limit wait completed, proceeding with request\")\n  return\n}\n","import { countTokens } from \"gpt-tokenizer/model/gpt-4o\"\n\nimport type { Message } from \"~/services/copilot/create-chat-completions\"\n\nexport const getTokenCount = (messages: Array<Message>) => {\n  const simplifiedMessages = messages.map((message) => {\n    let content = \"\"\n    if (typeof message.content === \"string\") {\n      content = message.content\n    } else if (Array.isArray(message.content)) {\n      content = message.content\n        .filter((part) => part.type === \"text\")\n        .map((part) => (part as { text: string }).text)\n        .join(\"\")\n    }\n    return { ...message, content }\n  })\n\n  let inputMessages = simplifiedMessages.filter((message) => {\n    return message.role !== \"tool\"\n  })\n  let outputMessages: typeof simplifiedMessages = []\n\n  const lastMessage = simplifiedMessages.at(-1)\n\n  if (lastMessage?.role === \"assistant\") {\n    inputMessages = simplifiedMessages.slice(0, -1)\n    outputMessages = [lastMessage]\n  }\n\n  // @ts-expect-error TS can't infer from arr.filter()\n  const inputTokens = countTokens(inputMessages)\n  // @ts-expect-error TS can't infer from arr.filter()\n  const outputTokens = countTokens(outputMessages)\n\n  return {\n    input: inputTokens,\n    output: outputTokens,\n  }\n}\n","import consola from \"consola\"\nimport { events } from \"fetch-event-stream\"\n\nimport { copilotHeaders, copilotBaseUrl } from \"~/lib/api-config\"\nimport { HTTPError } from \"~/lib/error\"\nimport { state } from \"~/lib/state\"\n\nexport const createChatCompletions = async (\n  payload: ChatCompletionsPayload,\n) => {\n  if (!state.copilotToken) throw new Error(\"Copilot token not found\")\n\n  const enableVision = payload.messages.some(\n    (x) =>\n      typeof x.content !== \"string\"\n      && x.content?.some((x) => x.type === \"image_url\"),\n  )\n\n  const response = await fetch(`${copilotBaseUrl(state)}/chat/completions`, {\n    method: \"POST\",\n    headers: copilotHeaders(state, enableVision),\n    body: JSON.stringify(payload),\n  })\n\n  if (!response.ok) {\n    consola.error(\"Failed to create chat completions\", response)\n    throw new HTTPError(\"Failed to create chat completions\", response)\n  }\n\n  if (payload.stream) {\n    return events(response)\n  }\n\n  return (await response.json()) as ChatCompletionResponse\n}\n\n// Streaming types\n\nexport interface ChatCompletionChunk {\n  id: string\n  object: \"chat.completion.chunk\"\n  created: number\n  model: string\n  choices: Array<Choice>\n  system_fingerprint?: string\n}\n\ninterface Delta {\n  content?: string | null\n  role?: \"user\" | \"assistant\" | \"system\" | \"tool\"\n  tool_calls?: Array<{\n    index: number\n    id?: string\n    type?: \"function\"\n    function?: {\n      name?: string\n      arguments?: string\n    }\n  }>\n}\n\ninterface Choice {\n  index: number\n  delta: Delta\n  finish_reason: \"stop\" | \"length\" | \"tool_calls\" | \"content_filter\" | null\n  logprobs: object | null\n}\n\n// Non-streaming types\n\nexport interface ChatCompletionResponse {\n  id: string\n  object: \"chat.completion\"\n  created: number\n  model: string\n  choices: Array<ChoiceNonStreaming>\n  system_fingerprint?: string\n  usage?: {\n    prompt_tokens: number\n    completion_tokens: number\n    total_tokens: number\n  }\n}\n\ninterface ResponseMessage {\n  role: \"assistant\"\n  content: string | null\n  tool_calls?: Array<ToolCall>\n}\n\ninterface ChoiceNonStreaming {\n  index: number\n  message: ResponseMessage\n  logprobs: object | null\n  finish_reason: \"stop\" | \"length\" | \"tool_calls\" | \"content_filter\"\n}\n\n// Payload types\n\nexport interface ChatCompletionsPayload {\n  messages: Array<Message>\n  model: string\n  temperature?: number | null\n  top_p?: number | null\n  max_tokens?: number | null\n  stop?: string | Array<string> | null\n  n?: number | null\n  stream?: boolean | null\n\n  frequency_penalty?: number | null\n  presence_penalty?: number | null\n  logit_bias?: Record<string, number> | null\n  logprobs?: boolean | null\n  response_format?: { type: \"json_object\" } | null\n  seed?: number | null\n  tools?: Array<Tool> | null\n  tool_choice?:\n    | \"none\"\n    | \"auto\"\n    | \"required\"\n    | { type: \"function\"; function: { name: string } }\n    | null\n  user?: string | null\n}\n\nexport interface Tool {\n  type: \"function\"\n  function: {\n    name: string\n    description?: string\n    parameters: Record<string, unknown>\n  }\n}\n\nexport interface Message {\n  role: \"user\" | \"assistant\" | \"system\" | \"tool\" | \"developer\"\n  content: string | Array<ContentPart> | null\n\n  name?: string\n  tool_calls?: Array<ToolCall>\n  tool_call_id?: string\n}\n\nexport interface ToolCall {\n  id: string\n  type: \"function\"\n  function: {\n    name: string\n    arguments: string\n  }\n}\n\nexport type ContentPart = TextPart | ImagePart\n\nexport interface TextPart {\n  type: \"text\"\n  text: string\n}\n\nexport interface ImagePart {\n  type: \"image_url\"\n  image_url: {\n    url: string\n    detail?: \"low\" | \"high\" | \"auto\"\n  }\n}\n","import { Hono } from \"hono\"\n\nimport { forwardError } from \"~/lib/error\"\nimport {\n  createEmbeddings,\n  type EmbeddingRequest,\n} from \"~/services/copilot/create-embeddings\"\n\nexport const embeddingRoutes = new Hono()\n\nembeddingRoutes.post(\"/\", async (c) => {\n  try {\n    const paylod = await c.req.json<EmbeddingRequest>()\n    const response = await createEmbeddings(paylod)\n\n    return c.json(response)\n  } catch (error) {\n    return await forwardError(c, error)\n  }\n})\n","import { copilotHeaders, copilotBaseUrl } from \"~/lib/api-config\"\nimport { HTTPError } from \"~/lib/error\"\nimport { state } from \"~/lib/state\"\n\nexport const createEmbeddings = async (payload: EmbeddingRequest) => {\n  if (!state.copilotToken) throw new Error(\"Copilot token not found\")\n\n  const response = await fetch(`${copilotBaseUrl(state)}/embeddings`, {\n    method: \"POST\",\n    headers: copilotHeaders(state),\n    body: JSON.stringify(payload),\n  })\n\n  if (!response.ok) throw new HTTPError(\"Failed to create embeddings\", response)\n\n  return (await response.json()) as EmbeddingResponse\n}\n\nexport interface EmbeddingRequest {\n  input: string | Array<string>\n  model: string\n}\n\nexport interface Embedding {\n  object: string\n  embedding: Array<number>\n  index: number\n}\n\nexport interface EmbeddingResponse {\n  object: string\n  data: Array<Embedding>\n  model: string\n  usage: {\n    prompt_tokens: number\n    total_tokens: number\n  }\n}\n","import { Hono } from \"hono\"\n\nimport { forwardError } from \"~/lib/error\"\n\nimport { handleCompletion } from \"./handler\"\n\nexport const messageRoutes = new Hono()\n\nmessageRoutes.post(\"/\", async (c) => {\n  try {\n    return await handleCompletion(c)\n  } catch (error) {\n    return await forwardError(c, error)\n  }\n})\n","import type { Context } from \"hono\"\n\nimport consola from \"consola\"\nimport { streamSSE } from \"hono/streaming\"\n\nimport { awaitApproval } from \"~/lib/approval\"\nimport { checkRateLimit } from \"~/lib/rate-limit\"\nimport { state } from \"~/lib/state\"\nimport {\n  createChatCompletions,\n  type ChatCompletionChunk,\n  type ChatCompletionResponse,\n} from \"~/services/copilot/create-chat-completions\"\n\nimport {\n  type AnthropicMessagesPayload,\n  type AnthropicStreamState,\n} from \"./anthropic-types\"\nimport {\n  translateToAnthropic,\n  translateToOpenAI,\n} from \"./non-stream-translation\"\nimport { translateChunkToAnthropicEvents } from \"./stream-translation\"\n\n// eslint-disable-next-line max-lines-per-function\nexport async function handleCompletion(c: Context) {\n  await checkRateLimit(state)\n\n  const anthropicPayload = await c.req.json<AnthropicMessagesPayload>()\n  consola.debug(\"Anthropic request payload:\", JSON.stringify(anthropicPayload))\n\n  const openAIPayload = translateToOpenAI(anthropicPayload)\n  consola.debug(\n    \"Translated OpenAI request payload:\",\n    JSON.stringify(openAIPayload),\n  )\n\n  if (state.manualApprove) {\n    await awaitApproval()\n  }\n\n  const response = await createChatCompletions(openAIPayload)\n\n  if (isNonStreaming(response)) {\n    consola.debug(\n      \"Non-streaming response from Copilot:\",\n      JSON.stringify(response).slice(-400),\n    )\n    const anthropicResponse = translateToAnthropic(response)\n    consola.debug(\n      \"Translated Anthropic response:\",\n      JSON.stringify(anthropicResponse),\n    )\n    return c.json(anthropicResponse)\n  }\n\n  consola.debug(\"Streaming response from Copilot\")\n  return streamSSE(c, async (stream) => {\n    const streamState: AnthropicStreamState = {\n      messageStartSent: false,\n      contentBlockIndex: 0,\n      contentBlockOpen: false,\n      toolCalls: {},\n    }\n\n    for await (const rawEvent of response) {\n      consola.debug(\"Copilot raw stream event:\", JSON.stringify(rawEvent))\n      if (rawEvent.data === \"[DONE]\") {\n        break\n      }\n\n      if (!rawEvent.data) {\n        continue\n      }\n\n      const chunk = JSON.parse(rawEvent.data) as ChatCompletionChunk\n      const events = translateChunkToAnthropicEvents(chunk, streamState)\n\n      for (const event of events) {\n        consola.debug(\"Translated Anthropic event:\", JSON.stringify(event))\n        await stream.writeSSE({\n          event: event.type,\n          data: JSON.stringify(event),\n        })\n      }\n    }\n  })\n}\n\nconst isNonStreaming = (\n  response: Awaited<ReturnType<typeof createChatCompletions>>,\n): response is ChatCompletionResponse => Object.hasOwn(response, \"choices\")\n","import { type AnthropicResponse } from \"./anthropic-types\"\n\nexport function mapOpenAIStopReasonToAnthropic(\n  finishReason: \"stop\" | \"length\" | \"tool_calls\" | \"content_filter\" | null,\n): AnthropicResponse[\"stop_reason\"] {\n  if (finishReason === null) {\n    return null\n  }\n  const stopReasonMap = {\n    stop: \"end_turn\",\n    length: \"max_tokens\",\n    tool_calls: \"tool_use\",\n    content_filter: \"end_turn\",\n  } as const\n  return stopReasonMap[finishReason]\n}\n","import {\n  type ChatCompletionResponse,\n  type ChatCompletionsPayload,\n  type ContentPart,\n  type Message,\n  type TextPart,\n  type Tool,\n  type ToolCall,\n} from \"~/services/copilot/create-chat-completions\"\n\nimport {\n  type AnthropicAssistantContentBlock,\n  type AnthropicAssistantMessage,\n  type AnthropicMessage,\n  type AnthropicMessagesPayload,\n  type AnthropicResponse,\n  type AnthropicTextBlock,\n  type AnthropicTool,\n  type AnthropicToolResultBlock,\n  type AnthropicToolUseBlock,\n  type AnthropicUserContentBlock,\n  type AnthropicUserMessage,\n} from \"./anthropic-types\"\nimport { mapOpenAIStopReasonToAnthropic } from \"./utils\"\n\n// Payload translation\n\nexport function translateToOpenAI(\n  payload: AnthropicMessagesPayload,\n): ChatCompletionsPayload {\n  return {\n    model: payload.model,\n    messages: translateAnthropicMessagesToOpenAI(\n      payload.messages,\n      payload.system,\n    ),\n    max_tokens: payload.max_tokens,\n    stop: payload.stop_sequences,\n    stream: payload.stream,\n    temperature: payload.temperature,\n    top_p: payload.top_p,\n    user: payload.metadata?.user_id,\n    tools: translateAnthropicToolsToOpenAI(payload.tools),\n    tool_choice: translateAnthropicToolChoiceToOpenAI(payload.tool_choice),\n  }\n}\n\nfunction translateAnthropicMessagesToOpenAI(\n  anthropicMessages: Array<AnthropicMessage>,\n  system: string | Array<AnthropicTextBlock> | undefined,\n): Array<Message> {\n  const systemMessages = handleSystemPrompt(system)\n\n  const otherMessages = anthropicMessages.flatMap((message) =>\n    message.role === \"user\" ?\n      handleUserMessage(message)\n    : handleAssistantMessage(message),\n  )\n\n  return [...systemMessages, ...otherMessages]\n}\n\nfunction handleSystemPrompt(\n  system: string | Array<AnthropicTextBlock> | undefined,\n): Array<Message> {\n  if (!system) {\n    return []\n  }\n\n  if (typeof system === \"string\") {\n    return [{ role: \"system\", content: system }]\n  } else {\n    const systemText = system.map((block) => block.text).join(\"\\n\\n\")\n    return [{ role: \"system\", content: systemText }]\n  }\n}\n\nfunction handleUserMessage(message: AnthropicUserMessage): Array<Message> {\n  const msgs: Array<Message> = []\n\n  if (Array.isArray(message.content)) {\n    const toolResultBlocks = message.content.filter(\n      (block): block is AnthropicToolResultBlock =>\n        block.type === \"tool_result\",\n    )\n    const textBlocks = message.content.filter((block) => block.type === \"text\")\n    const otherBlocks = message.content.filter(\n      (block) => block.type !== \"tool_result\" && block.type !== \"text\",\n    )\n    // OpenAI order: tool results FIRST, then user text (if any)\n    for (const block of toolResultBlocks) {\n      msgs.push({\n        role: \"tool\",\n        tool_call_id: block.tool_use_id,\n        content:\n          typeof block.content === \"string\" ?\n            block.content\n          : JSON.stringify(block.content),\n      })\n    }\n    if (textBlocks.length > 0 || otherBlocks.length > 0) {\n      const textContent = [\n        ...textBlocks.map((b) => b.text),\n        ...otherBlocks.map((b) => JSON.stringify(b)), // fallback for custom blocks\n      ]\n        .join(\"\\n\\n\")\n        .trim()\n      if (textContent.length > 0) {\n        msgs.push({\n          role: \"user\",\n          content: textContent,\n        })\n      }\n    }\n  } else {\n    msgs.push({\n      role: \"user\",\n      content: mapContent(message.content),\n    })\n  }\n  return msgs\n}\n\nfunction handleAssistantMessage(\n  message: AnthropicAssistantMessage,\n): Array<Message> {\n  if (!Array.isArray(message.content)) {\n    return [\n      {\n        role: \"assistant\",\n        content: mapContent(message.content),\n      },\n    ]\n  }\n\n  const toolUseBlocks = message.content.filter(\n    (block): block is AnthropicToolUseBlock => block.type === \"tool_use\",\n  )\n\n  const textBlocks = message.content.filter(\n    (block): block is AnthropicTextBlock => block.type === \"text\",\n  )\n\n  return toolUseBlocks.length > 0 ?\n      [\n        {\n          role: \"assistant\",\n          content: textBlocks.map((b) => b.text).join(\"\\n\\n\") || null,\n          tool_calls: toolUseBlocks.map((toolUse) => ({\n            id: toolUse.id,\n            type: \"function\",\n            function: {\n              name: toolUse.name,\n              arguments: JSON.stringify(toolUse.input),\n            },\n          })),\n        },\n      ]\n    : [\n        {\n          role: \"assistant\",\n          content: mapContent(message.content),\n        },\n      ]\n}\n\nfunction mapContent(\n  content:\n    | string\n    | Array<AnthropicUserContentBlock | AnthropicAssistantContentBlock>,\n): string | Array<ContentPart> | null {\n  if (typeof content === \"string\") {\n    return content\n  }\n  if (!Array.isArray(content)) {\n    return null\n  }\n\n  const hasImage = content.some((block) => block.type === \"image\")\n  if (!hasImage) {\n    return content\n      .filter((block): block is AnthropicTextBlock => block.type === \"text\")\n      .map((block) => block.text)\n      .join(\"\\n\\n\")\n  }\n\n  const contentParts: Array<ContentPart> = []\n  for (const block of content) {\n    if (block.type === \"text\") {\n      contentParts.push({ type: \"text\", text: block.text })\n    } else if (block.type === \"image\") {\n      contentParts.push({\n        type: \"image_url\",\n        image_url: {\n          url: `data:${block.source.media_type};base64,${block.source.data}`,\n        },\n      })\n    }\n  }\n  return contentParts\n}\n\nfunction translateAnthropicToolsToOpenAI(\n  anthropicTools: Array<AnthropicTool> | undefined,\n): Array<Tool> | undefined {\n  if (!anthropicTools) {\n    return undefined\n  }\n  return anthropicTools.map((tool) => ({\n    type: \"function\",\n    function: {\n      name: tool.name,\n      description: tool.description,\n      parameters: tool.input_schema,\n    },\n  }))\n}\n\nfunction translateAnthropicToolChoiceToOpenAI(\n  anthropicToolChoice: AnthropicMessagesPayload[\"tool_choice\"],\n): ChatCompletionsPayload[\"tool_choice\"] {\n  if (!anthropicToolChoice) {\n    return undefined\n  }\n\n  switch (anthropicToolChoice.type) {\n    case \"auto\": {\n      return \"auto\"\n    }\n    case \"any\": {\n      return \"required\"\n    }\n    case \"tool\": {\n      if (anthropicToolChoice.name) {\n        return {\n          type: \"function\",\n          function: { name: anthropicToolChoice.name },\n        }\n      }\n      return undefined\n    }\n    case \"none\": {\n      return \"none\"\n    }\n    default: {\n      return undefined\n    }\n  }\n}\n\n// Response translation\n\nexport function translateToAnthropic(\n  response: ChatCompletionResponse,\n): AnthropicResponse {\n  const choice = response.choices[0]\n  const textBlocks = getAnthropicTextBlocks(choice.message.content)\n  const toolUseBlocks = getAnthropicToolUseBlocks(choice.message.tool_calls)\n\n  return {\n    id: response.id,\n    type: \"message\",\n    role: \"assistant\",\n    model: response.model,\n    content: [...textBlocks, ...toolUseBlocks],\n    stop_reason: mapOpenAIStopReasonToAnthropic(choice.finish_reason),\n    stop_sequence: null,\n    usage: {\n      input_tokens: response.usage?.prompt_tokens ?? 0,\n      output_tokens: response.usage?.completion_tokens ?? 0,\n    },\n  }\n}\n\nfunction getAnthropicTextBlocks(\n  messageContent: Message[\"content\"],\n): Array<AnthropicTextBlock> {\n  if (typeof messageContent === \"string\") {\n    return [{ type: \"text\", text: messageContent }]\n  }\n\n  if (Array.isArray(messageContent)) {\n    return messageContent\n      .filter((part): part is TextPart => part.type === \"text\")\n      .map((part) => ({ type: \"text\", text: part.text }))\n  }\n\n  return []\n}\n\nfunction getAnthropicToolUseBlocks(\n  toolCalls: Array<ToolCall> | undefined,\n): Array<AnthropicToolUseBlock> {\n  if (!toolCalls) {\n    return []\n  }\n  return toolCalls.map((toolCall) => ({\n    type: \"tool_use\",\n    id: toolCall.id,\n    name: toolCall.function.name,\n    input: JSON.parse(toolCall.function.arguments) as Record<string, unknown>,\n  }))\n}\n","import { type ChatCompletionChunk } from \"~/services/copilot/create-chat-completions\"\n\nimport {\n  type AnthropicStreamEventData,\n  type AnthropicStreamState,\n} from \"./anthropic-types\"\nimport { mapOpenAIStopReasonToAnthropic } from \"./utils\"\n\nfunction isToolBlockOpen(state: AnthropicStreamState): boolean {\n  if (!state.contentBlockOpen) {\n    return false\n  }\n  // Check if the current block index corresponds to any known tool call\n  return Object.values(state.toolCalls).some(\n    (tc) => tc.anthropicBlockIndex === state.contentBlockIndex,\n  )\n}\n\n// eslint-disable-next-line max-lines-per-function, complexity\nexport function translateChunkToAnthropicEvents(\n  chunk: ChatCompletionChunk,\n  state: AnthropicStreamState,\n): Array<AnthropicStreamEventData> {\n  const events: Array<AnthropicStreamEventData> = []\n\n  if (chunk.choices.length === 0) {\n    return events\n  }\n\n  const choice = chunk.choices[0]\n  const { delta } = choice\n\n  if (!state.messageStartSent) {\n    events.push({\n      type: \"message_start\",\n      message: {\n        id: chunk.id,\n        type: \"message\",\n        role: \"assistant\",\n        content: [],\n        model: chunk.model,\n        stop_reason: null,\n        stop_sequence: null,\n        usage: {\n          input_tokens: 1,\n          output_tokens: 1, // Anthropic requires this to be > 0\n        },\n      },\n    })\n    state.messageStartSent = true\n  }\n\n  if (delta.content) {\n    if (isToolBlockOpen(state)) {\n      // A tool block was open, so close it before starting a text block.\n      events.push({\n        type: \"content_block_stop\",\n        index: state.contentBlockIndex,\n      })\n      state.contentBlockIndex++\n      state.contentBlockOpen = false\n    }\n\n    if (!state.contentBlockOpen) {\n      events.push({\n        type: \"content_block_start\",\n        index: state.contentBlockIndex,\n        content_block: {\n          type: \"text\",\n          text: \"\",\n        },\n      })\n      state.contentBlockOpen = true\n    }\n\n    events.push({\n      type: \"content_block_delta\",\n      index: state.contentBlockIndex,\n      delta: {\n        type: \"text_delta\",\n        text: delta.content,\n      },\n    })\n  }\n\n  if (delta.tool_calls) {\n    for (const toolCall of delta.tool_calls) {\n      if (toolCall.id && toolCall.function?.name) {\n        // New tool call starting.\n        if (state.contentBlockOpen) {\n          // Close any previously open block.\n          events.push({\n            type: \"content_block_stop\",\n            index: state.contentBlockIndex,\n          })\n          state.contentBlockIndex++\n          state.contentBlockOpen = false\n        }\n\n        const anthropicBlockIndex = state.contentBlockIndex\n        state.toolCalls[toolCall.index] = {\n          id: toolCall.id,\n          name: toolCall.function.name,\n          anthropicBlockIndex,\n        }\n\n        events.push({\n          type: \"content_block_start\",\n          index: anthropicBlockIndex,\n          content_block: {\n            type: \"tool_use\",\n            id: toolCall.id,\n            name: toolCall.function.name,\n            input: {},\n          },\n        })\n        state.contentBlockOpen = true\n      }\n\n      if (toolCall.function?.arguments) {\n        const toolCallInfo = state.toolCalls[toolCall.index]\n        // Tool call can still be empty\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (toolCallInfo) {\n          events.push({\n            type: \"content_block_delta\",\n            index: toolCallInfo.anthropicBlockIndex,\n            delta: {\n              type: \"input_json_delta\",\n              partial_json: toolCall.function.arguments,\n            },\n          })\n        }\n      }\n    }\n  }\n\n  if (choice.finish_reason) {\n    if (state.contentBlockOpen) {\n      events.push({\n        type: \"content_block_stop\",\n        index: state.contentBlockIndex,\n      })\n      state.contentBlockOpen = false\n    }\n\n    events.push({\n      type: \"message_delta\",\n      delta: {\n        stop_reason: mapOpenAIStopReasonToAnthropic(choice.finish_reason),\n        stop_sequence: null,\n      },\n      usage: {\n        output_tokens: 1,\n      },\n    })\n\n    events.push({\n      type: \"message_stop\",\n    })\n  }\n\n  return events\n}\n\nexport function translateErrorToAnthropicErrorEvent(): AnthropicStreamEventData {\n  return {\n    type: \"error\",\n    error: {\n      type: \"api_error\",\n      message: \"An unexpected error occurred during streaming.\",\n    },\n  }\n}\n","import { Hono } from \"hono\"\n\nimport { forwardError } from \"~/lib/error\"\nimport { state } from \"~/lib/state\"\nimport { cacheModels } from \"~/lib/utils\"\n\nexport const modelRoutes = new Hono()\n\nmodelRoutes.get(\"/\", async (c) => {\n  try {\n    if (!state.models) {\n      // This should be handled by startup logic, but as a fallback.\n      await cacheModels()\n    }\n\n    const models = state.models?.data.map((model) => ({\n      id: model.id,\n      object: \"model\",\n      type: \"model\",\n      created: 0, // No date available from source\n      created_at: new Date(0).toISOString(), // No date available from source\n      owned_by: model.vendor,\n      display_name: model.name,\n    }))\n\n    return c.json({\n      object: \"list\",\n      data: models,\n      has_more: false,\n    })\n  } catch (error) {\n    return await forwardError(c, error)\n  }\n})\n","import { Hono } from \"hono\"\n\nimport { state } from \"~/lib/state\"\n\nexport const tokenRoute = new Hono()\n\ntokenRoute.get(\"/\", (c) => {\n  try {\n    return c.json({\n      token: state.copilotToken,\n    })\n  } catch (error) {\n    console.error(\"Error fetching token:\", error)\n    return c.json({ error: \"Failed to fetch token\", token: null }, 500)\n  }\n})\n","import { Hono } from \"hono\"\n\nimport { getCopilotUsage } from \"~/services/github/get-copilot-usage\"\n\nexport const usageRoute = new Hono()\n\nusageRoute.get(\"/\", async (c) => {\n  try {\n    const usage = await getCopilotUsage()\n    return c.json(usage)\n  } catch (error) {\n    console.error(\"Error fetching Copilot usage:\", error)\n    return c.json({ error: \"Failed to fetch Copilot usage\" }, 500)\n  }\n})\n","import { GITHUB_API_BASE_URL, githubHeaders } from \"~/lib/api-config\"\nimport { HTTPError } from \"~/lib/error\"\nimport { state } from \"~/lib/state\"\n\nexport const getCopilotUsage = async (): Promise<CopilotUsageResponse> => {\n  const response = await fetch(`${GITHUB_API_BASE_URL}/copilot_internal/user`, {\n    headers: githubHeaders(state),\n  })\n\n  if (!response.ok) {\n    throw new HTTPError(\"Failed to get Copilot usage\", response)\n  }\n\n  return (await response.json()) as CopilotUsageResponse\n}\n\ninterface QuotaDetail {\n  entitlement: number\n  overage_count: number\n  overage_permitted: boolean\n  percent_remaining: number\n  quota_id: string\n  quota_remaining: number\n  remaining: number\n  unlimited: boolean\n}\n\ninterface QuotaSnapshots {\n  chat: QuotaDetail\n  completions: QuotaDetail\n  premium_interactions: QuotaDetail\n}\n\ninterface CopilotUsageResponse {\n  access_type_sku: string\n  analytics_tracking_id: string\n  assigned_date: string\n  can_signup_for_limited: boolean\n  chat_enabled: boolean\n  copilot_plan: string\n  organization_login_list: Array<unknown>\n  organization_list: Array<unknown>\n  quota_reset_date: string\n  quota_snapshots: QuotaSnapshots\n}\n"],"mappings":"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","names":["defineCommand","runMain","defineCommand","consola","fs","os","path","APP_DIR","GITHUB_TOKEN_PATH","PATHS","ensurePaths","ensureFile","filePath","state","consola","fs","randomUUID","standardHeaders","COPILOT_VERSION","EDITOR_PLUGIN_VERSION","USER_AGENT","API_VERSION","copilotBaseUrl","state","copilotHeaders","vision","headers","GITHUB_API_BASE_URL","githubHeaders","GITHUB_BASE_URL","GITHUB_CLIENT_ID","GITHUB_APP_SCOPES","consola","HTTPError","message","response","forwardError","c","error","errorText","getCopilotToken","response","GITHUB_API_BASE_URL","githubHeaders","state","HTTPError","getDeviceCode","response","GITHUB_BASE_URL","standardHeaders","GITHUB_CLIENT_ID","GITHUB_APP_SCOPES","HTTPError","getGitHubUser","response","GITHUB_API_BASE_URL","state","standardHeaders","HTTPError","consola","consola","getModels","response","copilotBaseUrl","state","copilotHeaders","HTTPError","FALLBACK","getVSCodeVersion","controller","timeout","pkgbuild","pkgverRegex","match","sleep","ms","resolve","isNullish","value","cacheModels","models","getModels","state","cacheVSCodeVersion","response","getVSCodeVersion","consola","pollAccessToken","deviceCode","sleepDuration","consola","response","GITHUB_BASE_URL","standardHeaders","GITHUB_CLIENT_ID","sleep","json","access_token","readGithubToken","fs","PATHS","writeGithubToken","token","setupCopilotToken","refresh_in","getCopilotToken","state","consola","refreshInterval","error","setupGitHubToken","options","githubToken","logUser","response","getDeviceCode","pollAccessToken","HTTPError","user","getGitHubUser","runAuth","options","consola","state","ensurePaths","setupGitHubToken","PATHS","auth","defineCommand","args","defineCommand","clipboard","consola","serve","invariant","execSync","process","getShell","platform","ppid","env","command","shellPath","generateEnvScript","envVars","commandToRun","shell","filteredEnvVars","value","commandBlock","key","assignments","Hono","cors","logger","Hono","consola","streamSSE","consola","awaitApproval","consola","HTTPError","consola","checkRateLimit","state","now","elapsedSeconds","waitTimeSeconds","consola","HTTPError","waitTimeMs","sleep","countTokens","getTokenCount","messages","simplifiedMessages","message","content","part","inputMessages","outputMessages","lastMessage","inputTokens","outputTokens","consola","events","createChatCompletions","payload","state","enableVision","x","response","copilotBaseUrl","copilotHeaders","consola","HTTPError","events","handleCompletion","c","checkRateLimit","state","payload","consola","getTokenCount","awaitApproval","isNullish","selectedModel","model","response","createChatCompletions","isNonStreaming","streamSSE","stream","chunk","completionRoutes","Hono","c","handleCompletion","error","forwardError","Hono","createEmbeddings","payload","state","response","copilotBaseUrl","copilotHeaders","HTTPError","embeddingRoutes","Hono","c","paylod","response","createEmbeddings","error","forwardError","Hono","consola","streamSSE","mapOpenAIStopReasonToAnthropic","finishReason","translateToOpenAI","payload","translateAnthropicMessagesToOpenAI","translateAnthropicToolsToOpenAI","translateAnthropicToolChoiceToOpenAI","anthropicMessages","system","systemMessages","handleSystemPrompt","otherMessages","message","handleUserMessage","handleAssistantMessage","block","msgs","toolResultBlocks","textBlocks","otherBlocks","textContent","b","mapContent","toolUseBlocks","toolUse","content","contentParts","anthropicTools","tool","anthropicToolChoice","translateToAnthropic","response","choice","getAnthropicTextBlocks","getAnthropicToolUseBlocks","mapOpenAIStopReasonToAnthropic","messageContent","part","toolCalls","toolCall","isToolBlockOpen","state","tc","translateChunkToAnthropicEvents","chunk","events","choice","delta","toolCall","anthropicBlockIndex","toolCallInfo","mapOpenAIStopReasonToAnthropic","handleCompletion","c","checkRateLimit","state","anthropicPayload","consola","openAIPayload","translateToOpenAI","awaitApproval","response","createChatCompletions","isNonStreaming","anthropicResponse","translateToAnthropic","streamSSE","stream","streamState","rawEvent","chunk","events","translateChunkToAnthropicEvents","event","messageRoutes","Hono","c","handleCompletion","error","forwardError","Hono","modelRoutes","Hono","c","state","cacheModels","models","model","error","forwardError","Hono","tokenRoute","Hono","c","state","error","Hono","getCopilotUsage","response","GITHUB_API_BASE_URL","githubHeaders","state","HTTPError","usageRoute","Hono","c","usage","getCopilotUsage","error","server","Hono","logger","cors","c","completionRoutes","modelRoutes","embeddingRoutes","usageRoute","tokenRoute","messageRoutes","runServer","options","consola","state","ensurePaths","cacheVSCodeVersion","setupGitHubToken","setupCopilotToken","cacheModels","model","serverUrl","invariant","selectedModel","selectedSmallModel","command","generateEnvScript","clipboard","serve","server","start","defineCommand","args","rateLimitRaw","rateLimit","main","defineCommand","auth","start","runMain"]}